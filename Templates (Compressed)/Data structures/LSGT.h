#define LSGT_DATA_TYPE long double
#define LSGT_Y_DATA_TYPE int
#define lC ((p)<<1)
#define rC (lC|1)
#define getMid int mid=(((l)+(r))>>1)
const LSGT_DATA_TYPE LSGT_EXP=1e-20;char LSGT_CMP(LSGT_DATA_TYPE a,LSGT_DATA_TYPE b){if(a-b>LSGT_EXP)return 1;if(b-a>LSGT_EXP)return-1;return 0;}struct LSGT_LINE{int id;LSGT_DATA_TYPE b,k;LSGT_DATA_TYPE calc(int pos){return k*pos+b;}friend char cmp(LSGT_LINE a,LSGT_LINE b,int pos){LSGT_DATA_TYPE v1=a.calc(pos);LSGT_DATA_TYPE v2=b.calc(pos);char res=LSGT_CMP(v1,v2);if(!res)res=(a.id<b.id)?1:(a.id==b.id?0:-1);return res;}friend LSGT_LINE lmax(LSGT_LINE a,LSGT_LINE b,int pos){char res=cmp(a,b,pos);if(res==-1)return b;return a;}};const int LSGT_TREE_SIZE=100000;const int LSGT_LINE_SIZE=100000;struct LSGT_TREE{int tree[LSGT_TREE_SIZE<<2];LSGT_LINE lines[LSGT_LINE_SIZE];int L,R;void down(int p,int l,int r,int tag){getMid;if(cmp(lines[tree[p]],lines[tag],mid)==-1)std::swap(tree[p],tag);if(cmp(lines[tree[p]],lines[tag],l)==-1)down(lC,l,mid,tag);if(cmp(lines[tree[p]],lines[tag],r)==-1)down(rC,mid+1,r,tag);return;}void insert(int p,int l,int r,int s,int t,int tag){if(s<=l&&r<=t)return down(p,l,r,tag);getMid;if(s<=mid)insert(lC,l,mid,s,t,tag);if(mid<t)insert(rC,mid+1,r,s,t,tag);return;}LSGT_LINE query(int p,int l,int r,int pos){if(l==r)return lines[tree[p]];getMid;if(pos<=mid)return lmax(lines[tree[p]],query(lC,l,mid,pos),pos);else return lmax(lines[tree[p]],query(rC,mid+1,r,pos),pos);}void build(int l,int r){lines[0].id=lines[0].k=0;lines[0].b=0;return(void)(L=l,R=r);}void insert(int s,int t,LSGT_LINE tag){lines[tag.id]=tag;return insert(1,L,R,s,t,tag.id);}void insert(LSGT_LINE tag){lines[tag.id]=tag;return down(1,L,R,tag.id);}void insert(int x0,LSGT_Y_DATA_TYPE y0,int x1,LSGT_Y_DATA_TYPE y1,int id){LSGT_LINE line;line.id=id;if(x0>x1)std::swap(x0,x1),std::swap(y0,y1);if(x0==x1)line.b=std::max(y0,y1),line.k=0;else line.k=((LSGT_DATA_TYPE)(y0-y1))/((LSGT_DATA_TYPE)(x0-x1)),line.b=y0-line.k*x0;return insert(x0,x1,line);}LSGT_LINE query(int pos){return query(1,L,R,pos);}};