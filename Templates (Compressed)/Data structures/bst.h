#include<cstring>
#define BST_DATA_TYPE int
const int BST_SIZE=1000000;struct BSTNode{BST_DATA_TYPE data;int lChild,rChild;BSTNode(){lChild=-1;rChild=-1;return;}};struct BST{BSTNode bst[BST_SIZE];int rear,rest,head,num,s[BST_SIZE];void build(){num=rest=0;head=-1;return;}int getMemory(){if(rest<BST_SIZE)releaseMemory(rest++);return s[--rear];}void releaseMemory(int address){bst[address].data=0;bst[address].lChild=bst[address].rChild=-1;s[rear++]=address;return;}int search(BST_DATA_TYPE key){int p=head;while(~p){if(key==bst[p].data)break;if(key<=bst[p].data)p=bst[p].lChild;else p=bst[p].rChild;}return p;}void insert(BST_DATA_TYPE key){register int p=head;int address=getMemory();while(~p)if(key<=bst[p].data)if(bst[p].lChild==-1){bst[p].lChild=address;break;}else p=bst[p].lChild;else if(bst[p].rChild==-1){bst[p].rChild=address;break;}else p=bst[p].rChild;bst[address].data=key;if(num==0)head=address;num++;return;}void del(BST_DATA_TYPE key){register int p=head,q=head,s,pa;while(~p){if(key==bst[p].data)break;if(key<=bst[p].data)q=p,p=bst[p].lChild;else q=p,p=bst[p].rChild;}if(p==-1)return;num--;if(bst[p].lChild==-1&&bst[p].rChild==-1){releaseMemory(p);if(p==head){head=-1;return;}if(bst[q].lChild==p){bst[q].lChild=-1;}else{bst[q].rChild=-1;}}else if(bst[p].lChild!=-1&&bst[p].rChild!=-1){q=p;s=bst[p].rChild;while(~bst[s].lChild)q=s,s=bst[s].lChild;bst[p].data=bst[s].data;if(q!=p)bst[q].lChild=bst[s].rChild;else bst[p].rChild=bst[s].rChild;releaseMemory(s);}else{if(bst[p].lChild==-1)s=bst[p].rChild;else s=bst[p].lChild;releaseMemory(p);if(p==head){head=s;return;}if(bst[q].lChild==p){bst[q].lChild=s;}else{bst[q].rChild=s;}}return;}};