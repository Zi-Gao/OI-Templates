#include<algorithm>
#define ZSEG_DATA_TYPE long long
#define ZSEG_TAG_TYPE long long
const int ZSEG_SIZE=100000;struct ZSGT_NODE{ZSEG_TAG_TYPE tag;ZSEG_DATA_TYPE data;ZSGT_NODE(){data=0;return;}};struct ZSGT{ZSGT_NODE tree[ZSEG_SIZE<<2];int size;inline ZSEG_DATA_TYPE mergeData(ZSEG_DATA_TYPE first,ZSEG_DATA_TYPE second){return first+second;}inline ZSEG_DATA_TYPE getData(ZSEG_DATA_TYPE data,ZSEG_TAG_TYPE tag,int len){return data+tag*len;}inline ZSEG_TAG_TYPE mergeTag(ZSEG_TAG_TYPE first,ZSEG_TAG_TYPE second){return first+second;}inline ZSEG_TAG_TYPE getTag(ZSEG_TAG_TYPE a,int pos){return a;}void build(ZSEG_DATA_TYPE*data,int n){register int i;int logn=std::__lg(n+2)+1;size=1<<logn;for(i=1;i<=n;++i)tree[size+i].data=data[i];for(i=size;i;--i)tree[i].data=mergeData(tree[i<<1].data,tree[i<<1|1].data);return;}ZSEG_DATA_TYPE query(register int l,register int r){register int len=1,cntl=0,cntr=0;register ZSEG_DATA_TYPE ansl=0,ansr=0;for(l+=size-1,r+=size+1;l^r^1;l>>=1,r>>=1,len<<=1){ansl=getData(ansl,tree[l].tag,cntl),ansr=getData(ansr,tree[r].tag,cntr);if(~l&1)ansl=mergeData(ansl,tree[l^1].data),cntl+=len;if(r&1)ansr=mergeData(tree[r^1].data,ansr),cntr+=len;}for(;l;l>>=1,r>>=1)ansl=getData(ansl,tree[l].tag,cntl),ansr=getData(ansr,tree[r].tag,cntr);return mergeData(ansl,ansr);}void update(register int l,register int r,ZSEG_TAG_TYPE tag){register int len=1,cntl=0,cntr=0,lencp=r-l;register ZSEG_TAG_TYPE tagl=tag,tagr=tag;for(l+=size-1,r+=size+1;l^r^1;l>>=1,r>>=1,len<<=1){tree[l].data=getData(tree[l].data,tagl,cntl),tree[r].data=getData(tree[r].data,tagr,cntr);if(~l&1)tree[l^1].data=getData(tree[l^1].data,tagl,len),tree[l^1].tag=mergeTag(tree[l^1].tag,tagl),cntl+=len;if(r&1)tree[r^1].data=getData(tree[r^1].data,tagr,len),tree[r^1].tag=mergeTag(tree[r^1].tag,tagr),cntr+=len;tagl=getTag(tag,cntl),tagr=getTag(tag,lencp-cntr);}for(;l;l>>=1,r>>=1)tree[l].data=getData(tree[l].data,tagl,cntl),tree[r].data=getData(tree[r].data,tagr,cntr);return;}};